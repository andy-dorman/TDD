<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h1>Test Driven Development</h1>
				</section>

				<section>
					<h2>Wikipedia says:</h2>
					<p>Test-driven development (TDD) is a software development process that relies on the repetition
					of a very short development cycle.</p>
					<ul>
						<li class="fragment">Requirements are turned into very specific test cases.</li>
						<li class="fragment">The software is improved to pass the new tests, only.</li>
					</ul>
				</section>

				<section>
					<h2>Benefits</h2>
					<ul>
						<li>Tickets should become more clear. By the end of analysis the tickets should have unambiguous requirements.</li>
						<li class="fragment">Tests should cover the requirements of the ticket, and not potentially buggy current functionality.</li>
						<li class="fragment">After the tests are written, if the ticket needs to go back to next, another developer could write the code to fix the tests, and pass all requirements of the ticket.</li>
						<li class="fragment">The tests will explain our thought process, will aid clarity to other members of the team.</li>
					</ul>
				</section>

				<section>
					<h2>More Benefits</h2>
					<ul>
						<li>QA can be involved from the start of the ticket, to catch areas the Devs have missed.</li>
						<li class="fragment">Less feature creep. If a dev feels the need to add more tests after analysis, we should be checking whether the extra work is out of scope.</li>
						<li class="fragment">For QAs: We get evidence that the requirements for a ticket are tested and fulfilled.</li>
						<li class="fragment">Communication between ticket owner, dev and QA throughout the life of the ticket.</li>
					</ul>
				</section>

				<section>
					<h1>TDD in Practice</h1>
				</section>

				<section>
					<h2>Analysis</h2>
					<ul>
						<li>If the ticket has some ambiguity, it could be that the ticket has not met our definition of ready.</li>
						<li class="fragment">If the ambiguity is an implementation detail, remove all ambiguity during the analysis phase.</li>
						<li class="fragment">If the ticket doesn't have a set of requirements in the description, add them.</li>
						<li class="fragment">Make sure that the requirements include different scenarios if needed.</li>
						<li class="fragment">If you don't think that a requirement can be easily translated into a test, rewrite it until it can be. Make sure with the team that your rewrite covers all it needs to.</li>
						<li class="fragment">If you have added more requirements, get agreement that the requirements you have added are in scope. If not in scope, a new ticket is needed.</li>
						<li class="fragment">Check with the team to make sure your requirements and tests cover all they need to, before entering the development phase of the ticket.</li>
						<li class="fragment">Use analysis as a code review stage for the requirements and the tests.</li>
					</ul>
				</section>

				<section>
					<h2>Writing tests</h2>
					<ul>
						<li>You should write your tests during the analysis stage.</li>
						<li class="fragment">Start small.</li>
						<li class="fragment">Test iteratively.</li>
						<li class="fragment">Make sure that tests follow logically from the previous tests.</li>
						<li class="fragment">Only write tests that help you meet the requirements.</li>
						<li class="fragment">Write the tests before writing any code.</li>
						<li class="fragment">Write tests that fail, and then write code to make the tests pass.</li>
						<li class="fragment">It's okay to have lots of failing tests before writing any code.</li>
					</ul>
				</section>

				<section>
					<h2>Writing code</h2>
					<ul>
						<li>Only write code that fixes tests.</li>
						<li class="fragment">If code isn't relevant to a test you have written, it is out of scope or needs a test.</li>
						<li class="fragment">Fix tests in the most simple way possible.</li>
						<li class="fragment">By simplest way possible, that includes hardcoding the expected result. If you see hardcoded results in your final code it means you have not tested hard enough.</li>
						<li class="fragment">When you are fixing the tests, focus on fixing one test at a time.</li>
						<li class="fragment">Keep previous tests running when you are fixing a new test.</li>
					</ul>
				</section>

				<section>
					<h2>Merge Requests</h2>
					<p>Now we have all the requirements with passing tests, now is the time to see if our code can be improved. Our existing merge request process already works well for this, so I'm moving on.</p>
				</section>

				<section>
					<h1>Example</h1>
					<p>We are writing code to help people play a drinking game called Buffalo. The rules:</p>
					<ul>
						<li class="fragment">Imagine an analogue clock. If the minute hand is on the right hand side of the clock, between 0 and 29 minutes, drink with your right hand.</li>
						<li class="fragment">If the minute hand of the analogue clock is on the left side, between 30 - 59 minutes, drink with your left hand.</li>
						<li class="fragment">If you are caught drinking with the wrong hand, bad things happen.</li>
					</ul>
				</section>

				<section>
					<h2>Requirements</h2>
					<div>We want a method called buffalo that takes a number between 0 and 59, and returns either the word 'right' or 'left' depending on the number's value</div>
					<ul>
						<li class="fragment">If the number is between 0 and 29, return 'right'</li>
						<li class="fragment">If the number is between 30 and 59, return 'left'</li>
						<li class="fragment">If the number is less than 0 or greater than 59, return nothing</li>
					</ul>
				</section>

				<section>
					<h2>Our first test</h2>
					<p>
						The first test should test whether the method exists, and it doesn't crash the app when used.
						If the code we are testing is a component, we would check whether the component can render without crashing.
					</p>
					<p class="fragment">
						Code: The test should fail because we do not have the code yet. We should be able to write an empty method,
						and this test should pass. If you already wrote the empty method, comment it out and the test should fail.
					</p>
				</section>

				<section>
					<h2>Our second test</h2>
					<p>The second test should test the first requirement, Which is: If the number is 0, return 'right'.</p>
					<p class="fragment">
						Code: We would write the code to pass this test. The simplest way to pass this test is to return the
						hardcoded value 'right'. We don't need to do anything with the number yet.
					</p>
				</section>

				<section>
					<h2>Our third test</h2>
					<p>The third test should test the following requirement: If the number is 30, return 'left'.</p>
					<p class="fragment">
						Code: Our code needs to be a little bit more clever. If we tried to change the hardcoded value to 'left',
						the first test would now fail. So, we now need to check the number to see if the number is 0. If so,
						return 'right'. Otherwise, return 'left'
					</p>
				</section>

				<section>
					<h2>Testing the bounds.</h2>
					<p>
						We need to check our boundaries. Write tests to return 'right' if the number is 29,
						'left' if the number is 59.
					</p>
					<p class="fragment">
						If these tests already pass, make sure to comment out code to break them. We want to make
						sure that the tests are testing what you think they are.
					</p>
				</section>

				<section>
						<h2>Testing inside the bounds.</h2>
						<p>
							We need to test a few numbers between 0 and 29 to make sure that they return 'right'.
							Also test a few numbers between 30 and 59 to see if they return 'left'.
						</p>
						<p class="fragment">
							This is where we should be writing code that checks whether the value of the number
							is within a range, rather than checking for values explicitly. Keep your other tests
							running to make sure we don't break previous requirements.
						</p>
						<p class="fragment">
							If these tests already pass, make sure to comment out code to break them.
							We want to make sure that the tests are testing what you think they are.
						</p>
					</section>

				<section>
					<h2>Testing unexpected values.</h2>
					<p>Write a few tests to return null when the number is less than 0 or greater than 59.</p>
					<p class="fragment">
						Either write the code to pass the tests, or if the tests are passing,
						comment out your code until it breaks as expected.
					</p>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
		<style>
		.reveal {
			font-size: 30px;
		}
		</style>
	</body>
</html>
