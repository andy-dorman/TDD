<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>TDD</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h1>Test Driven Development</h1>
				</section>

				<section>
					<h2>Wikipedia says:</h2>
					<p>Test-driven development (TDD) is a software development process that relies on the repetition
					of a very short development cycle.</p>
					<ul>
						<li class="fragment">Requirements are turned into very specific test cases.</li>
						<li class="fragment">The software is improved to pass the new tests, only.</li>
					</ul>
				</section>

				<section>
					<h2>Benefits</h2>
					<ul>
						<li>Tickets should become more clear.</li>
						<li class="fragment">By the end of analysis the tickets should have unambiguous requirements.</li>
						<li class="fragment">Tests should cover the requirements of the ticket and not assumptions of the developer.</li>
						<li class="fragment">After the tests are written, if the ticket needs to go back to next, another developer could write the code to fix the tests, and pass all requirements of the ticket.</li>
						<li class="fragment">The tests will explain the developer's thought process, which will aid clarity to other members of the team.</li>
					</ul>
				</section>

				<section>
					<h2>More Benefits</h2>
					<ul>
						<li>QA can be involved from the start of the ticket, to catch areas the Devs have missed.</li>
						<li class="fragment">Less feature creep. If a Dev feels the need to add more tests after analysis, they should check whether the extra work is out of scope.</li>
						<li class="fragment">QAs get evidence that the requirements for a ticket are tested and fulfilled.</li>
						<li class="fragment">Communication between Ticket Owner, Dev and QA throughout the life of the ticket.</li>
					</ul>
				</section>

				<section>
					<h1>TDD in Practice</h1>
				</section>

				<section>
					<h2>Analysis</h2>
					<ul>
						<li>If the ticket has some ambiguity, it could be that the ticket has not met our definition of ready.</li>
						<li class="fragment">If the ambiguity is an implementation detail, remove all ambiguity during the analysis phase.</li>
						<li class="fragment">If the ticket doesn't have a set of requirements in the description, add them.</li>
						<li class="fragment">Make sure that the requirements include different scenarios if needed.</li>
					</ul>
				</section>

				<section>
					<h2>Analysis</h2>
					<ul>
						<li>If a requirement cannot be easily translated into a test, rewrite it until it can be.</li>
						<li class="fragment">If more requirements have been added, get agreement that the new requirements are in scope. It could be that a new ticket is needed.</li>
						<li class="fragment">Check with the team to make sure requirements and tests cover all they need to before entering the development phase of the ticket.</li>
						<li class="fragment">Use analysis as a requirement and test review stage.</li>
					</ul>
				</section>

				<section>
					<h2>Writing tests</h2>
					<ul>
						<li>Write tests during the analysis stage.</li>
						<li class="fragment">Start small.</li>
						<li class="fragment">Test iteratively.</li>
						<li class="fragment">Tests should follow logically from the previous tests.</li>
						<li class="fragment">Only write tests that help meet the requirements.</li>
						<li class="fragment">Write the tests before writing code.</li>
						<li class="fragment">If the test fails before writing your code, this means that you are testing the right thing.</li>
						<li class="fragment">If the test already passes before you write any code because previous code covers your test, break your code to make sure that the test fails as expected. Fix your code again afterwards.</li>
					</ul>
				</section>

				<section>
					<h2>Writing code</h2>
					<ul>
						<li>Only write code that fixes tests.</li>
						<li class="fragment">If code isn't relevant to a test, it needs a test or is out of scope.</li>
						<li class="fragment">Fix tests in the most simple way possible.</li>
						<li class="fragment">Fix one test at a time.</li>
						<li class="fragment">Keep previous tests running when fixing a new test to stop you breaking previous functionality.</li>
					</ul>
				</section>

				<section>
					<h2>Merge Requests</h2>
					<p>Now all the requirements have passing tests, check to see if the code can be improved. After you are happy, ask your favourite code enforcer to check your work.</p>
				</section>

				<section><h1>Example</h1></section>

				<section>
					<p>We are writing code to help people play a game called Buffalo. The rules:</p>
					<ul>
						<li class="fragment">If the minute hand of a clock is on the right, between 0 and 29 minutes, drink with your right hand.</li>
						<li class="fragment">If the minute hand of a clock is on the left, between 30 and 59 minutes, drink with your left hand.</li>
						<li class="fragment">If a player is caught drinking with the wrong hand, bad things happen.</li>
					</ul>
				</section>

				<section>
					<h2>Requirements</h2>
					<div>We want a function called buffalo that takes a number between 0 and 59, and returns either the word 'right' or 'left' depending on the number's value.</div>
					<ul>
						<li class="fragment">If the number is between 0 and 29, return 'right'.</li>
						<li class="fragment">If the number is between 30 and 59, return 'left'.</li>
						<li class="fragment">If the number is less than 0 or greater than 59, return nothing.</li>
					</ul>
				</section>

				<section>
					<h2>The First Test</h2>
					<p>
						The first test should test whether the function exists, and it doesn't crash the app when used.
					</p>
					<p class="fragment">
						If the code is a component, we would check whether the component can render without crashing.
					</p>
					<p class="fragment">
						The test should fail to begin with, because we do not have any code to test yet.
						We should be able to write an empty function, and this test should pass.
					</p>
				</section>

				<section>
					<h2>The Second Test</h2>
					<p>The second test should test the first requirement, Which is:</p>
					<p>If the number is 0, return 'right'.</p>

					<p class="fragment">
						The simplest way to pass this test is to return the hardcoded value 'right'.
						There is no need to do anything with the number yet as this causes the test to pass.
					</p>
				</section>

				<section>
					<h2>The Third Test</h2>
					<p>The third test should test the following requirement:</p>
					<p>If the number is 29, return 'right'.</p>
					<p class="fragment">
						The code already written should pass this test.
						To make sure that the test is testing what we think it is testing,
						Change the return value from 'right' to 'left' and see both tests fail.
					</p>
				</section>

				<section>
					<h2>The Fourth Test</h2>
					<p>The fourth test should test the following requirement:</p>
					<p>If the number is 30, return 'left'.</p>
					<p class="fragment">
						Our code needs to be a little bit more clever. If we tried to change the hardcoded value to 'left',
						the first and second tests would fail.
					</p>
					<p class="fragment">
						There are a few ways to write this code, but aim for the simplest way you can think of to make the test pass.
						One way to write this code is to check if the number is 30. If so, return 'left', otherwise, return 'right'.
					</p>
				</section>

				<section>
					<h2>The Fifth Test</h2>
					<p>The fifth test should test the following requirement:</p>
					<p>If the number is 59, return 'left'.</p>
					<p class="fragment">We can make this test pass by expanding the if statement to also check for 59.</p>
				</section>

				<section>
					<h2>Testing inside the bounds.</h2>
					<p>
						We have tested the boundaries of the requirements, but we now need to test inside the boundaries.
						Test a few numbers between 0 and 29 to see if they return 'right'.
						Test a few numbers between 30 and 59 to see if they return 'left'.
					</p>
					<p class="fragment">
						We should be checking whether the number is within a range at this point, rather than
						checking for values explicitly. Keep your other tests running to make sure we don't
						break previous requirements.
					</p>
					<p class="fragment">
						Again, if these tests pass before you write more code, comment out code to break them.
						We want to make sure that the tests are testing what you think they are testing.
					</p>
				</section>

				<section>
					<h2>Testing values outside the bounds.</h2>
					<p>Write a few tests to return null when the number is less than 0 or greater than 59.</p>
					<p class="fragment">
						Either write the code to pass the tests, or if the tests are passing,
						comment out your code until it breaks as expected.
					</p>
				</section>

				<section>
					<h2>Tests that the QAs caught</h2>
					<p>QAs are better at finding edge cases than I am. They added the following tests:</p>
					<ul>
						<li class="fragment">What happens if we pass the code 'NaN', meaning not a number</li>
						<li class="fragment">What happens if we pass the code a decimal</li>
						<li class="fragment">What happens if we pass the code a super long number</li>
						<li class="fragment">What happens if we pass a superlong negative number</li>
					</ul>
					<p class="fragment">They thought of more but the number input field caught the edge cases before they could reach my code.</p>
				</section>

				<section>
					<h2>Done!</h2>
					<p>We should have tests that match the initial requirements, and code that fulfills the tests.</p>
					<p>Make sure that your tests cover the requirements, and the code is the simplest it can be while passing the tests.</p>
					<p>:D</p>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
		<style>
		.reveal {
			font-size: 30px;
		}
		</style>
	</body>
</html>
